/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/api-keys/{apikey}": {
    /** Revoke the current API key so that it cannot be used anymore */
    delete: {
      parameters: {
        path: {
          /** The API Key to revoke */
          apikey: string;
        };
      };
      responses: {
        /** The key has been deleted */
        200: unknown;
        /** The key is not found for this user */
        404: unknown;
      };
    };
  };
  "/api/v1/api-keys/current": {
    /** View information about the current API key */
    get: {
      responses: {
        /** Information about the current api key */
        200: {
          content: {
            "application/json": components["schemas"]["ApiKeyData"];
          };
        };
      };
    };
    /** Revoke the current API key so that it cannot be used anymore */
    delete: {
      responses: {
        /** The key was revoked and is no longer usable */
        200: {
          content: {
            "application/json": components["schemas"]["ApiKeyData"];
          };
        };
      };
    };
  };
  "/api/v1/api-keys": {
    /** Create a new API Key */
    post: {
      responses: {
        /** Information about the new api key */
        200: {
          content: {
            "application/json": components["schemas"]["ApiKeyData"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": {
            /** The label of the new API Key */
            label?: string | null;
            /** The permissions granted to this API Key (See API Key Authentication) */
            permissions?: string[] | null;
          };
        };
      };
    };
  };
  "/api-keys/authorize": {
    /** Redirect the browser to this endpoint to request the user to generate an api-key with specific permissions */
    get: {
      parameters: {
        query: {
          /** The permissions to request. (See API Key authentication) */
          permissions?: string[] | null;
          /** The name of your application */
          applicationName?: string | null;
          /** If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting. */
          strict?: boolean | null;
          /** If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user's control. */
          selectiveStores?: boolean | null;
          /** The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list. */
          redirect?: string | null;
          /** If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). `applicationIdentifier` is ignored if redirect is not specified. */
          applicationIdentifier?: string | null;
        };
      };
      responses: {
        /** A HTML form that a user can use to confirm permissions to grant */
        200: {
          content: {
            "text/html": unknown;
          };
        };
        /** Makes browser do an HTTP POST request to the specified url in `redirect` with a JSON body consisting of `apiKey` (the api key created or matched), `permissions` (the permissions the user consented to), and `userId` (the id of the user that consented) upon consent */
        307: never;
      };
    };
  };
  "/api/v1/health": {
    /** Check the instance health status */
    get: operations["Health_GetHealth"];
  };
  "/api/v1/stores/{storeId}/invoices": {
    /** View information about the existing invoices */
    get: operations["Invoices_GetInvoices"];
    /** Create a new invoice */
    post: operations["Invoices_CreateInvoice"];
  };
  "/api/v1/stores/{storeId}/invoices/{invoiceId}": {
    /** View information about the specified invoice */
    get: operations["Invoices_GetInvoice"];
    /** Updates the specified invoice. */
    put: operations["Invoices_UpdateInvoice"];
    /** Archives the specified invoice. */
    delete: operations["Invoices_ArchiveInvoice"];
  };
  "/api/v1/stores/{storeId}/invoices/{invoiceId}/payment-methods": {
    /** View information about the specified invoice's payment methods */
    get: operations["Invoices_GetInvoicePaymentMethods"];
    /** Archives the specified invoice. */
    delete: operations["Invoices_ArchiveInvoice"];
  };
  "/api/v1/stores/{storeId}/invoices/{invoiceId}/status": {
    /** Mark an invoice as invalid or settled. */
    post: operations["Invoices_MarkInvoiceStatus"];
  };
  "/api/v1/stores/{storeId}/invoices/{invoiceId}/unarchive": {
    /** Unarchive an invoice */
    post: operations["Invoices_UnarchiveInvoice"];
  };
  "/api/v1/stores/{storeId}/invoices/{invoiceId}/payment-methods/{paymentMethod}/activate": {
    /** Activate an invoice payment method (if lazy payments mode is enabled) */
    post: operations["Invoices_ActivatePaymentMethod"];
  };
  "/api/v1/server/lightning/{cryptoCode}/info": {
    /** View information about the lightning node */
    get: operations["InternalLightningNodeApi_GetInfo"];
  };
  "/api/v1/server/lightning/{cryptoCode}/connect": {
    /** Connect to another lightning node. */
    post: operations["InternalLightningNodeApi_ConnectToNode"];
  };
  "/api/v1/server/lightning/{cryptoCode}/channels": {
    /** View information about the current channels of the lightning node */
    get: operations["InternalLightningNodeApi_GetChannels"];
    /** Open a channel with another lightning node. You should connect to that node first. */
    post: operations["InternalLightningNodeApi_OpenChannel"];
  };
  "/api/v1/server/lightning/{cryptoCode}/address": {
    /** Get an on-chain deposit address for the lightning node */
    post: operations["InternalLightningNodeApi_GetDepositAddress"];
  };
  "/api/v1/server/lightning/{cryptoCode}/invoices/{id}": {
    /** View information about the requested lightning invoice */
    get: operations["InternalLightningNodeApi_GetInvoice"];
  };
  "/api/v1/server/lightning/{cryptoCode}/invoices/pay": {
    /** Pay a lightning invoice. */
    post: operations["InternalLightningNodeApi_PayInvoice"];
  };
  "/api/v1/server/lightning/{cryptoCode}/invoices": {
    /** Create a lightning invoice. */
    post: operations["InternalLightningNodeApi_CreateInvoice"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/info": {
    /** View information about the lightning node */
    get: operations["StoreLightningNodeApi_GetInfo"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/connect": {
    /** Connect to another lightning node. */
    post: operations["StoreLightningNodeApi_ConnectToNode"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/channels": {
    /** View information about the current channels of the lightning node */
    get: operations["StoreLightningNodeApi_GetChannels"];
    /** Open a channel with another lightning node. You should connect to that node first. */
    post: operations["StoreLightningNodeApi_OpenChannel"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/address": {
    /** Get an on-chain deposit address for the lightning node */
    post: operations["StoreLightningNodeApi_GetDepositAddress"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/{id}": {
    /** View information about the requested lightning invoice */
    get: operations["StoreLightningNodeApi_GetInvoice"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices/pay": {
    /** Pay a lightning invoice. */
    post: operations["StoreLightningNodeApi_PayInvoice"];
  };
  "/api/v1/stores/{storeId}/lightning/{cryptoCode}/invoices": {
    /** Create a lightning invoice. */
    post: operations["StoreLightningNodeApi_CreateInvoice"];
  };
  "/misc/permissions": {
    /** The metadata of available permissions */
    get: operations["permissionsMetadata"];
  };
  "/misc/lang": {
    /** The supported language codes */
    get: operations["langCodes"];
  };
  "/i/{invoiceId}": {
    /** View the checkout page of an invoice */
    get: {
      parameters: {
        path: {
          /** The invoice id */
          invoiceId: string;
        };
        query: {
          /** The preferred language of the checkout page. You can use "auto" to use the language of the customer's browser or see the list of language codes with [this operation](#operation/langCodes). */
          lang?: string;
        };
      };
      responses: {
        /** The checkout page */
        200: {
          content: {
            "text/html": unknown;
          };
        };
      };
    };
    parameters: {
      path: {
        /** The invoice id */
        invoiceId: string;
      };
      query: {
        /** The preferred language of the checkout page. You can use "auto" to use the language of the customer's browser or see the list of language codes with [this operation](#operation/langCodes). */
        lang?: string;
      };
    };
  };
  "/api/v1/users/me/notifications": {
    /** View current user's notifications */
    get: operations["Notifications_GetNotifications"];
  };
  "/api/v1/users/me/notifications/{id}": {
    /** View information about the specified notification */
    get: operations["Notifications_GetNotification"];
    /** Updates the notification */
    put: operations["Notifications_UpdateNotification"];
    /** Removes the specified notification. */
    delete: operations["Notifications_DeleteNotification"];
  };
  "/api/v1/stores/{storeId}/payment-requests": {
    /** View information about the existing payment requests */
    get: operations["PaymentRequests_GetPaymentRequests"];
    /** Create a new payment request */
    post: operations["PaymentRequests_CreatePaymentRequest"];
  };
  "/api/v1/stores/{storeId}/payment-requests/{paymentRequestId}": {
    /** View information about the specified payment request */
    get: operations["PaymentRequests_GetPaymentRequest"];
    /** Update a payment request */
    put: operations["PaymentRequests_UpdatePaymentRequest"];
    /** Archives the specified payment request. */
    delete: operations["PaymentRequests_ArchivePaymentRequest"];
  };
  "/api/v1/stores/{storeId}/pull-payments": {
    /** Get the pull payments of a store */
    get: operations["PullPayments_GetPullPayments"];
    /** A pull payment allows its receiver to ask for payouts up to `amount` of `currency` every `period`. */
    post: operations["PullPayments_CreatePullPayment"];
    parameters: {
      path: {
        /** The store ID */
        storeId: string;
      };
    };
  };
  "/api/v1/pull-payments/{pullPaymentId}": {
    /** Get a pull payment */
    get: operations["PullPayments_GetPullPayment"];
    parameters: {
      path: {
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/pull-payments/{pullPaymentId}": {
    /** Archive this pull payment (Will cancel all payouts awaiting for payment) */
    delete: operations["PullPayments_ArchivePullPayment"];
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
    };
  };
  "/api/v1/pull-payments/{pullPaymentId}/payouts": {
    /** Get payouts */
    get: operations["PullPayments_GetPayouts"];
    /** Create a new payout */
    post: operations["PullPayments_CreatePayout"];
    parameters: {
      path: {
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/payouts/{payoutId}": {
    /** Approve a payout */
    post: operations["PullPayments_ApprovePayout"];
    /** Cancel the payout */
    delete: operations["PullPayments_CancelPayout"];
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the payout */
        payoutId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/payouts/{payoutId}/mark-paid": {
    /** Mark a payout as paid */
    post: operations["PullPayments_MarkPayoutPaid"];
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the payout */
        payoutId: string;
      };
    };
  };
  "/api/v1/server/info": {
    /** Information about the server, chains and sync states */
    get: operations["ServerInfo_GetServerInfo"];
  };
  "/api/v1/stores/{storeId}/payment-methods": {
    /** View information about the stores' configured payment methods */
    get: operations["StorePaymentMethods_GetStorePaymentMethods"];
  };
  "/api/v1/stores/{storeId}/payment-methods/LightningNetwork": {
    /** View information about the stores' configured Lightning Network payment methods */
    get: operations["StoreLightningNetworkPaymentMethods_GetLightningNetworkPaymentMethods"];
  };
  "/api/v1/stores/{storeId}/payment-methods/LightningNetwork/{cryptoCode}": {
    /** View information about the specified payment method */
    get: operations["StoreLightningNetworkPaymentMethods_GetLightningNetworkPaymentMethod"];
    /** Update the specified store's payment method */
    put: operations["StoreLightningNetworkPaymentMethods_UpdateLightningNetworkPaymentMethod"];
    /** Removes the specified store payment method. */
    delete: {
      parameters: {
        path: {
          /** The store to fetch */
          storeId: string;
          /** The crypto code of the payment method to update */
          cryptoCode: string;
        };
      };
      responses: {
        /** The payment method has been removed */
        200: unknown;
        /** A list of errors that occurred when removing the payment method */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
        /** If you are authenticated but forbidden to remove the specified payment method */
        403: unknown;
        /** The key is not found for this store/payment-method */
        404: unknown;
      };
    };
  };
  "/api/v1/stores/{storeId}/payment-methods/LNURL": {
    /** View information about the stores' configured LNURL payment methods */
    get: operations["StoreLNURLPayPaymentMethods_GetLNURLPayPaymentMethods"];
  };
  "/api/v1/stores/{storeId}/payment-methods/LNURL/{cryptoCode}": {
    /** View information about the specified payment method */
    get: operations["StoreLNURLPayPaymentMethods_GetLNURLPayPaymentMethod"];
    /** Update the specified store's payment method */
    put: operations["StoreLNURLPayPaymentMethods_UpdateLNURLPayPaymentMethod"];
    /** Removes the specified store payment method. */
    delete: {
      parameters: {
        path: {
          /** The store to fetch */
          storeId: string;
          /** The crypto code of the payment method to update */
          cryptoCode: string;
        };
      };
      responses: {
        /** The payment method has been removed */
        200: unknown;
        /** A list of errors that occurred when removing the payment method */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
        /** If you are authenticated but forbidden to remove the specified payment method */
        403: unknown;
        /** The key is not found for this store/payment-method */
        404: unknown;
      };
    };
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain": {
    /** View information about the stores' configured on-chain payment methods */
    get: operations["StoreOnChainPaymentMethods_GetOnChainPaymentMethods"];
  };
  "/api/v1/stores/{storeId}/payment-methods/onchain/{cryptoCode}": {
    /** View information about the specified payment method */
    get: operations["StoreOnChainPaymentMethods_GetOnChainPaymentMethod"];
    /** Update the specified store's payment method */
    put: operations["StoreOnChainPaymentMethods_UpdateOnChainPaymentMethod"];
    /** Removes the specified store payment method. */
    delete: {
      parameters: {
        path: {
          /** The store to fetch */
          storeId: string;
          /** The crypto code of the payment method to update */
          cryptoCode: string;
        };
      };
      responses: {
        /** The payment method has been removed */
        200: unknown;
        /** A list of errors that occurred when removing the payment method */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
        /** If you are authenticated but forbidden to remove the specified payment method */
        403: unknown;
        /** The key is not found for this store/payment-method */
        404: unknown;
      };
    };
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/preview": {
    /** View addresses of the current payment method of the store */
    get: operations["StoreOnChainPaymentMethods_GetOnChainPaymentMethodPreview"];
    /** View addresses of a proposed payment method of the store */
    post: operations["StoreOnChainPaymentMethods_GetOnChainPaymentMethodPreview"];
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/wallet": {
    /** View information about the specified wallet */
    get: operations["StoreOnChainWallets_ShowOnChainWalletOverview"];
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/wallet/feeRate": {
    /** Get wallet onchain fee rate */
    get: operations["StoreOnChainWallets_GetOnChainFeeRate"];
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/wallet/address": {
    /** Get or generate address for wallet */
    get: operations["StoreOnChainWallets_GetOnChainWalletReceiveAddress"];
    /** UnReserve address */
    delete: operations["StoreOnChainWallets_UnReserveOnChainWalletReceiveAddress"];
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/wallet/transactions": {
    /** Get store on-chain wallet transactions */
    get: operations["StoreOnChainWallets_ShowOnChainWalletTransactions"];
    /** Create store on-chain wallet transaction */
    post: operations["StoreOnChainWallets_CreateOnChainTransaction"];
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/wallet/transactions/{transactionId}": {
    /** Get store on-chain wallet transaction */
    get: operations["StoreOnChainWallets_GetOnChainWalletTransaction"];
  };
  "/api/v1/stores/{storeId}/payment-methods/OnChain/{cryptoCode}/wallet/utxos": {
    /** Get store on-chain wallet utxos */
    get: operations["StoreOnChainWallets_GetOnChainWalletUTXOs"];
  };
  "/api/v1/stores": {
    /** View information about the available stores */
    get: operations["Stores_GetStores"];
    /** Create a new store */
    post: {
      responses: {
        /** Information about the new store */
        200: {
          content: {
            "application/json": components["schemas"]["StoreData"];
          };
        };
        /** A list of errors that occurred when creating the store */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
        /** If you are authenticated but forbidden to add new stores */
        403: unknown;
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["StoreBaseData"];
        };
      };
    };
  };
  "/api/v1/stores/{storeId}": {
    /** View information about the specified store */
    get: operations["Stores_GetStore"];
    /** Update the specified store */
    put: operations["Stores_UpdateStore"];
    /** Removes the specified store. If there is another user with access, only your access will be removed. */
    delete: {
      parameters: {
        path: {
          /** The store to remove */
          storeId: string;
        };
      };
      responses: {
        /** The store has been removed */
        200: unknown;
        /** A list of errors that occurred when removing the store */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
        /** If you are authenticated but forbidden to remove the specified store */
        403: unknown;
        /** The key is not found for this store */
        404: unknown;
      };
    };
  };
  "/api/v1/users/me": {
    /** View information about the current user */
    get: operations["Users_GetCurrentUser"];
    /** Deletes user profile and associated user data for user making the request */
    delete: operations["Users_DeleteCurrentUser"];
  };
  "/api/v1/users": {
    /**
     * Create a new user.
     *
     * This operation can be called without authentication in any of this cases:
     * * There is not any administrator yet on the server,
     * * The subscriptions are not disabled in the server's policies.
     *
     * If the first administrator is created by this call, subscriptions are automatically disabled.
     */
    post: {
      responses: {
        /** Information about the new user */
        201: {
          content: {
            "application/json": components["schemas"]["ApplicationUserData"];
          };
        };
        /** A list of errors that occurred when creating the user */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
        /** If you need to authenticate for this endpoint (ie. the server settings policies lock subscriptions and that an admin already exists) */
        401: unknown;
        /** If you are authenticated but forbidden to create a new user (ie. you don't have the `unrestricted` permission on a server administrator or if you are not administrator and registrations are disabled in the server's policies) */
        403: unknown;
        /** DDoS protection if you are creating more than 2 accounts every minutes (non-admin only) */
        429: unknown;
      };
      requestBody: {
        content: {
          "application/json": {
            /** The email of the new user */
            email?: string;
            /** The password of the new user */
            password?: string;
            /** Make this user administrator (only if you have the `unrestricted` permission of a server administrator) */
            isAdministrator?: boolean | null;
          };
        };
      };
    };
  };
  "/api/v1/users/{userId}": {
    /**
     * Delete a user.
     *
     * Must be an admin to perform this operation.
     *
     * Attempting to delete the only admin user will not succeed.
     *
     * All data associated with the user will be deleted as well if the operation succeeds.
     */
    delete: {
      parameters: {
        path: {
          /** The ID of the user to be deleted */
          userId: string;
        };
      };
      responses: {
        /** User has been successfully deleted */
        200: unknown;
        /** Missing authorization for deleting the user */
        401: unknown;
        /** Authorized but forbidden to delete the user. Can happen if you attempt to delete the only admin user. */
        403: unknown;
        /** User with provided ID was not found */
        404: unknown;
      };
    };
  };
  "/api/v1/stores/{storeId}/webhooks": {
    /** View webhooks of a store */
    get: operations["Webhokks_GetWebhooks"];
    /** Create a new webhook */
    post: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
        };
      };
      responses: {
        /** Information about the new webhook */
        200: {
          content: {
            "application/json": components["schemas"]["WebhookDataCreate"];
          };
        };
        /** A list of errors that occurred when creating the webhook */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["WebhookDataCreate"];
        };
      };
    };
    parameters: {
      path: {
        /** The store id */
        storeId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/webhooks/{webhookId}": {
    /** View webhook of a store */
    get: operations["Webhokks_GetWebhook"];
    /** Update a webhook */
    put: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
          /** The webhook id */
          webhookId: string;
        };
      };
      responses: {
        /** Information about the updated webhook */
        200: {
          content: {
            "application/json": components["schemas"]["WebhookData"];
          };
        };
        /** A list of errors that occurred when creating the webhook */
        400: {
          content: {
            "application/json": components["schemas"]["ValidationProblemDetails"];
          };
        };
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["WebhookDataBase"];
        };
      };
    };
    /** Delete a webhook */
    delete: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
          /** The webhook id */
          webhookId: string;
        };
      };
      responses: {
        /** The webhook has been deleted */
        200: unknown;
        /** The webhook does not exist */
        404: unknown;
      };
      requestBody: {
        content: {
          "application/json": components["schemas"]["WebhookDataBase"];
        };
      };
    };
    parameters: {
      path: {
        /** The store id */
        storeId: string;
        /** The webhook id */
        webhookId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries": {
    /** List the latest deliveries to the webhook, ordered from the most recent */
    get: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
          /** The webhook id */
          webhookId: string;
        };
        query: {
          /** The number of latest deliveries to fetch */
          count?: string;
        };
      };
      responses: {
        /** List of deliveries */
        200: {
          content: {
            "application/json": components["schemas"]["WebhookDeliveryList"];
          };
        };
      };
    };
    parameters: {
      path: {
        /** The store id */
        storeId: string;
        /** The webhook id */
        webhookId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries/{deliveryId}": {
    /** Information about a webhook delivery */
    get: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
          /** The webhook id */
          webhookId: string;
          /** The id of the delivery */
          deliveryId: string;
        };
      };
      responses: {
        /** Information about a delivery */
        200: {
          content: {
            "application/json": components["schemas"]["WebhookDeliveryData"];
          };
        };
        /** The delivery does not exists. */
        404: unknown;
      };
    };
    parameters: {
      path: {
        /** The store id */
        storeId: string;
        /** The webhook id */
        webhookId: string;
        /** The id of the delivery */
        deliveryId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries/{deliveryId}/request": {
    /** The delivery's JSON request sent to the endpoint */
    get: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
          /** The webhook id */
          webhookId: string;
          /** The id of the delivery */
          deliveryId: string;
        };
      };
      responses: {
        /** The delivery's JSON Request */
        200: {
          content: {
            "application/json": { [key: string]: unknown };
          };
        };
        /** The delivery does not exists. */
        404: unknown;
      };
    };
    parameters: {
      path: {
        /** The store id */
        storeId: string;
        /** The webhook id */
        webhookId: string;
        /** The id of the delivery */
        deliveryId: string;
      };
    };
  };
  "/api/v1/stores/{storeId}/webhooks/{webhookId}/deliveries/{deliveryId}/redeliver": {
    /** Redeliver the delivery */
    post: {
      parameters: {
        path: {
          /** The store id */
          storeId: string;
          /** The webhook id */
          webhookId: string;
          /** The id of the delivery */
          deliveryId: string;
        };
      };
      responses: {
        /** The new delivery id being broadcasted. (Broadcast happen asynchronously with this call) */
        200: {
          content: {
            "application/json": string;
          };
        };
        /** The delivery does not exists. */
        404: unknown;
      };
    };
    parameters: {
      path: {
        /** The store id */
        storeId: string;
        /** The webhook id */
        webhookId: string;
        /** The id of the delivery */
        deliveryId: string;
      };
    };
  };
}

export interface components {
  schemas: {
    ApiKeyData: {
      /** The API Key to use for API Key Authentication */
      apiKey?: string;
      /** The label given by the user to this API Key */
      label?: string;
      /** The permissions associated to this API Key */
      permissions?: string[];
    };
    ApplicationHealthData: {
      /** True if the instance is fully synchronized, according to NBXplorer */
      synchronized?: boolean;
    };
    InvoiceDataList: components["schemas"]["InvoiceData"][];
    MarkInvoiceStatusRequest: {
      /** Mark an invoice as completed or invalid. */
      status?: components["schemas"]["InvoiceStatusMark"];
    };
    AddCustomerEmailRequest: {
      /** Sets the customer email, if it was not set before. */
      email?: string;
    };
    InvoiceStatusMark: "Invalid" | "Settled";
    InvoiceStatus: "New" | "Processing" | "Expired" | "Invalid" | "Settled";
    /** An additional status that describes why an invoice is in its current status. */
    InvoiceAdditionalStatus:
      | "None"
      | "PaidLate"
      | "PaidPartial"
      | "Marked"
      | "Invalid"
      | "PaidOver";
    InvoiceDataBase: {
      metadata?: components["schemas"]["InvoiceMetadata"];
      /** Additional settings to customize the checkout flow */
      checkout?: components["schemas"]["CheckoutOptions"] | null;
    };
    InvoiceData: components["schemas"]["InvoiceDataBase"] & {
      /** The identifier of the invoice */
      id?: string;
      /** The store identifier that the invoice belongs to */
      storeId?: string;
      /** The amount of the invoice */
      amount?: string;
      /** The currency of the invoice */
      currency?: string;
      /** The type of invoice */
      type?: components["schemas"]["InvoiceType"];
      /** The link to the checkout page, where you can redirect the customer */
      checkoutLink?: string;
      /** The creation time of the invoice */
      createdTime?: components["schemas"]["UnixTimestamp"];
      /** The expiration time of the invoice */
      expirationTime?: components["schemas"]["UnixTimestamp"];
      /** The monitoring time of the invoice */
      monitoringTime?: components["schemas"]["UnixTimestamp"];
      /** The status of the invoice */
      status?: components["schemas"]["InvoiceStatus"];
      /** a secondary status of the invoice */
      additionalStatus?: components["schemas"]["InvoiceAdditionalStatus"];
      /** The statuses the invoice can be manually marked as */
      availableStatusesForManualMarking?: components["schemas"]["InvoiceStatus"][];
      /** true if the invoice is archived */
      archived?: boolean;
    };
    /** shown on the invoice details page */
    InvoiceMetadataPosString: string;
    /** Any json object in any schema you want. Will be rendered on a best effort basis in terms of style on the invoice details UI */
    InvoiceMetadataPosObject: { [key: string]: unknown };
    /** Additional information around the invoice that can be supplied. The mentioned properties are all optional and you can introduce any json format you wish. */
    InvoiceMetadata: (Partial<{
      /** You can use this property to store the ID of an external system. We allow you to search in the invoice list based on this ID. */
      orderId?: string | null;
      /** You can use this property to store the URL to the order of an external system. This makes navigating to the order easier. */
      orderUrl?: string | null;
    }> &
      Partial<{
        posData?:
          | components["schemas"]["InvoiceMetadataPosString"]
          | components["schemas"]["InvoiceMetadataPosObject"];
      }> &
      Partial<{
        buyerName?: string | null;
      }> &
      Partial<{
        buyerEmail?: string | null;
      }> &
      Partial<{
        buyerCountry?: string | null;
      }> &
      Partial<{
        buyerZip?: string | null;
      }> &
      Partial<{
        buyerState?: string | null;
      }> &
      Partial<{
        buyerCity?: string | null;
      }> &
      Partial<{
        buyerAddress1?: string | null;
      }> &
      Partial<{
        buyerAddress2?: string | null;
      }> &
      Partial<{
        buyerPhone?: string | null;
      }> &
      Partial<{
        itemDesc?: string | null;
      }> &
      Partial<{
        itemCode?: string | null;
      }> &
      Partial<{
        physical?: string | null;
      }> &
      Partial<{
        taxIncluded?: number | null;
      }>) & { [key: string]: unknown };
    CreateInvoiceRequest: components["schemas"]["InvoiceDataBase"] & {
      /** The amount of the invoice. If null or unspecified, the invoice will be a top-up invoice. (ie. The invoice will consider any payment as a full payment) */
      amount?: string | null;
      /** The currency of the invoice (if null, empty or unspecified, the currency will be the store's settings default)' */
      currency?: string | null;
      /** Additional search term to help you find this invoice via text search */
      additionalSearchTerms?: string[] | null;
    };
    UpdateInvoiceRequest: {
      metadata?: components["schemas"]["InvoiceMetadata"];
    };
    CheckoutOptions: {
      /** This is a risk mitigation parameter for the merchant to configure how they want to fulfill orders depending on the number of block confirmations for the transaction made by the consumer on the selected cryptocurrency */
      speedPolicy?: components["schemas"]["SpeedPolicy"] | null;
      /** A specific set of payment methods to use for this invoice (ie. BTC, BTC-LightningNetwork). By default, select all payment methods enabled in the store. */
      paymentMethods?: string[] | null;
      /** Default payment type for the invoice (e.g., BTC, BTC-LightningNetwork). Default payment method set for the store is used if this parameter is not specified. */
      defaultPaymentMethod?: string | null;
      /** The number of minutes after which an invoice becomes expired. Defaults to the store's settings. (The default store settings is 15) */
      expirationMinutes?: components["schemas"]["TimeSpanMinutes"] | null;
      /** The number of minutes after an invoice expired after which we are still monitoring for incoming payments. Defaults to the store's settings. (The default store settings is 1440, 1 day) */
      monitoringMinutes?: number | null;
      /** A percentage determining whether to count the invoice as paid when the invoice is paid within the specified margin of error. Defaults to the store's settings. (The default store settings is 100) */
      paymentTolerance?: number | null;
      /** When the customer has paid the invoice, the URL where the customer will be redirected when clicking on the `return to store` button. You can use placeholders `{InvoiceId}` or `{OrderId}` in the URL, BTCPay Server will replace those with this invoice `id` or `metadata.orderId` respectively. */
      redirectURL?: string | null;
      /** When the customer has paid the invoice, and a `redirectURL` is set, the checkout is redirected to `redirectURL` automatically if `redirectAutomatically` is true. Defaults to the store's settings. (The default store settings is false) */
      redirectAutomatically?: boolean | null;
      /** Invoice will require user to provide a refund email if this option is set to `true`. Has no effect if `buyerEmail` metadata is set as there is no email to collect in this case. */
      requiresRefundEmail?: boolean | null;
      /** The language code (eg. en-US, en, fr-FR...) of the language presented to your customer in the checkout page. BTCPay Server tries to match the best language available. If null or not set, will fallback on the store's default language. You can see the list of language codes with [this operation](#operation/langCodes). */
      defaultLanguage?: string | null;
    };
    SpeedPolicy: "HighSpeed" | "MediumSpeed" | "LowSpeed" | "LowMediumSpeed";
    InvoicePaymentMethodDataModel: {
      /** The payment method */
      paymentMethod?: string;
      /** The destination the payment must be made to */
      destination?: string;
      /** A payment link that helps pay to the payment destination */
      paymentLink?: string | null;
      /** The rate between this payment method's currency and the invoice currency */
      rate?: string;
      /** The amount paid by this payment method */
      paymentMethodPaid?: string;
      /** The total amount paid by all payment methods to the invoice, converted to this payment method's currency */
      totalPaid?: string;
      /** The total amount left to be paid, converted to this payment method's currency (will be negative if overpaid) */
      due?: string;
      /** The invoice amount, converted to this payment method's currency */
      amount?: string;
      /** The added merchant fee to pay for network costs of this payment method. */
      networkFee?: string;
      /** Payments made with this payment method. */
      payments?: components["schemas"]["Payment"][];
      /** If the payment method is activated (when lazy payments option is enabled */
      activated?: boolean;
    };
    Payment: {
      /** A unique identifier for this payment */
      id?: string;
      /** The date the payment was recorded */
      receivedDate?: components["schemas"]["UnixTimestamp"];
      /** The value of the payment */
      value?: string;
      /** The fee paid for the payment */
      fee?: string;
      /** The status of the payment */
      status?: components["schemas"]["PaymentStatus"];
      /** The destination the payment was made to */
      destination?: string;
    };
    PaymentStatus: "Invalid" | "Processing" | "Settled";
    InvoiceType: "Standard" | "TopUp";
    /** An array of validation errors of the request */
    ValidationProblemDetails: {
      /** The json path of the property which failed validation */
      path?: string;
      /** User friendly error message about the validation */
      message?: string;
    }[];
    /** Description of an error happening during processing of the request */
    ProblemDetails: {
      /** An error code describing the error */
      code?: string;
      /** User friendly error message about the error */
      message?: string;
    };
    /** A unix timestamp in seconds */
    UnixTimestamp: number;
    TimeSpan: number;
    /** A span of times in seconds */
    TimeSpanSeconds: components["schemas"]["TimeSpan"];
    /** A span of times in minutes */
    TimeSpanMinutes: components["schemas"]["TimeSpan"];
    ConnectToNodeRequest: {
      /** Node URI in the form `pubkey@endpoint[:port]` */
      nodeURI?: string | null;
    };
    CreateLightningInvoiceRequest: {
      /** Amount wrapped in a string, represented in a millistatoshi string. (1000 millisatoshi = 1 satoshi) */
      amount?: string;
      /** Description of the invoice in the BOLT11 */
      description?: string | null;
      /** Expiration time in seconds */
      expiry?: components["schemas"]["TimeSpanSeconds"];
      /** True if the invoice should include private route hints */
      privateRouteHints?: boolean | null;
    };
    LightningChannelData: {
      /** The public key of the node (Node ID) */
      remoteNode?: string;
      /** Whether the node is public */
      isPublic?: boolean;
      /** Whether the node is online */
      isActive?: boolean;
      /** The capacity of the channel in millisatoshi */
      capacity?: string;
      /** The local balance of the channel in millisatoshi */
      localBalance?: string;
      channelPoint?: string | null;
    };
    LightningInvoiceData: {
      /** The invoice's ID */
      id?: string;
      status?: components["schemas"]["LightningInvoiceStatus"];
      /** The BOLT11 representation of the invoice */
      BOLT11?: string;
      /** The unix timestamp when the invoice got paid */
      paidAt?: components["schemas"]["UnixTimestamp"] | null;
      /** The unix timestamp when the invoice expires */
      expiresAt?: components["schemas"]["UnixTimestamp"];
      /** The amount of the invoice in millisatoshi */
      amount?: string;
      /** The amount received in millisatoshi */
      amountReceived?: string;
    };
    LightningInvoiceStatus: "Unpaid" | "Paid" | "Expired";
    LightningNodeInformationData: {
      /** Node URIs to connect to this node in the form `pubkey@endpoint[:port]` */
      nodeURIs?: string[];
      /** The block height of the lightning node */
      blockHeight?: number;
    };
    PayLightningInvoiceRequest: {
      /** The BOLT11 of the invoice to pay */
      BOLT11?: string;
    };
    OpenLightningChannelRequest: {
      /** Node URI in the form `pubkey@endpoint[:port]` */
      nodeURI?: string;
      /** The amount to fund (in satoshi) */
      channelAmount?: string;
      /** The amount to fund (in satoshi per byte) */
      feeRate?: number;
    };
    UpdateNotification: {
      /** Sets the notification as seen/unseen. If left null, sets it to the opposite value */
      seen?: boolean | null;
    };
    NotificationData: {
      /** The identifier of the notification */
      id?: string;
      /** The html body of the notifications */
      body?: string;
      /** The link of the notification */
      link?: string | null;
      /** The creation time of the notification */
      createdTime?: components["schemas"]["UnixTimestamp"];
      /** If the notification has been seen by the user */
      seen?: boolean;
    };
    PaymentRequestDataList: components["schemas"]["PaymentRequestData"][];
    PaymentRequestData: {
      /** The id of the payment request */
      id?: string;
      /** The status of the payment request */
      status?: "Pending" | "Completed" | "Expired";
      /** The creation date of the payment request */
      created?: components["schemas"]["UnixTimestamp"];
    } & { [key: string]: components["schemas"]["PaymentRequestBaseData"] };
    PaymentRequestBaseData: {
      /** The amount of the payment request */
      amount?: string;
      /** The title of the payment request */
      title?: string;
      /** The currency of the payment request */
      currency?: string;
      /** The email used in invoices generated by the payment request */
      email?: string | null;
      /** The description of the payment request */
      description?: string | null;
      /** The expiry date of the payment request */
      expiryDate?: components["schemas"]["UnixTimestamp"] | null;
      /** Custom CSS styling for the payment request */
      embeddedCSS?: string | null;
      /** Custom CSS link for styling the payment request */
      customCSSLink?: string | null;
      /** Whether to allow users to create invoices that partially pay the payment request */
      allowCustomPaymentAmounts?: boolean | null;
    };
    PullPaymentDataList: components["schemas"]["PullPaymentData"][];
    PayoutDataList: components["schemas"]["PayoutData"][];
    CreatePayoutRequest: {
      /** The destination of the payout (can be an address or a BIP21 url) */
      destination?: string;
      /** The amount of the payout in the currency of the pull payment (eg. USD). */
      amount?: string;
      /** The payment method of the payout */
      paymentMethod?: string;
    };
    PayoutData: {
      /** The id of the payout */
      id?: string;
      /** The revision number of the payout. This revision number is incremented when the payout amount or destination is modified before the approval. */
      revision?: number;
      /** The id of the pull payment this payout belongs to */
      pullPaymentId?: string;
      /** The creation date of the payout as a unix timestamp */
      date?: string;
      /** The destination of the payout (can be an address or a BIP21 url) */
      destination?: string;
      /** The amount of the payout in the currency of the pull payment (eg. USD). */
      amount?: string;
      /** The payment method of the payout */
      paymentMethod?: string;
      /** The amount of the payout in the currency of the payment method (eg. BTC). This is only available from the `AwaitingPayment` state. */
      paymentMethodAmount?: string | null;
      /** The state of the payout (`AwaitingApproval`, `AwaitingPayment`, `InProgress`, `Completed`, `Cancelled`) */
      state?:
        | "AwaitingApproval"
        | "AwaitingPayment"
        | "InProgress"
        | "Completed"
        | "Cancelled";
    };
    PullPaymentData: {
      /** Id of the pull payment */
      id?: string;
      /** Payment method of of the pull payment */
      name?: string;
      /** The currency of the pull payment's amount */
      currency?: string;
      /** The amount in the currency of this pull payment as a decimal string */
      amount?: string;
      /** The length of each period in seconds */
      period?: number | null;
      /** Whether this pull payment is archived */
      archived?: boolean;
      /** The link to a page to claim payouts to this pull payment */
      viewLink?: string;
    };
    ApplicationServerInfoData: {
      /** BTCPay Server version */
      version?: string;
      /** The Tor hostname */
      onion?: string;
      /** The payment methods this server supports */
      supportedPaymentMethods?: string[];
      /** True if the instance is fully synchronized, according to NBXplorer */
      fullySynched?: boolean;
      syncStatus?: components["schemas"]["ApplicationServerInfoSyncStatusData"][];
    };
    /** Detailed sync status of the internal full node */
    ApplicationServerInfoNodeStatusData: {
      /** The height of the chain of header of the internal full node */
      headers?: number;
      /** The height of the latest validated block of the internal full node */
      blocks?: number;
      /** The current synchronization progress */
      verificationProgress?: number;
    } | null;
    /** Detailed sync status */
    ApplicationServerInfoSyncStatusData: {
      /** The CryptoCode of the crypto currency (eg. BTC) */
      cryptoCode?: string;
      nodeInformation?: components["schemas"]["ApplicationServerInfoNodeStatusData"];
      /** The height of the chain of header of the internal indexer */
      chainHeight?: number;
      /** The height of the latest indexed block of the internal indexer */
      syncHeight?: number | null;
    };
    GenericPaymentMethodData: {
      /** Whether the payment method is enabled */
      enabled?: boolean;
      /** The currency code of the payment method */
      cryptoCode?: boolean;
      /** Associated dynamic data based on payment method type. */
      data?:
        | components["schemas"]["OnChainPaymentMethodBaseData"]
        | components["schemas"]["LightningNetworkPaymentMethodBaseData"]
        | { [key: string]: unknown };
    };
    LightningNetworkPaymentMethodDataList: components["schemas"]["LightningNetworkPaymentMethodData"][];
    LightningNetworkPaymentMethodBaseData: {
      /** The lightning connection string. Set to 'Internal Node' to use the internal node. (See [this doc](https://github.com/btcpayserver/BTCPayServer.Lightning/blob/master/README.md#examples) for some example) */
      connectionString?: string;
      /** Whether to disable generation of bolt11 invoices. Useful when wanting to only use LNURL Pay exclusively. */
      disableBOLT11PaymentOption?: boolean;
    };
    LightningNetworkPaymentMethodData: {
      /** Whether the payment method is enabled */
      enabled?: boolean;
      /** Crypto code of the payment method */
      cryptoCode?: string;
      /** The payment method */
      paymentMethod?: string;
    } & {
      [
        key: string
      ]: components["schemas"]["LightningNetworkPaymentMethodBaseData"];
    };
    UpdateLightningNetworkPaymentMethodRequest: {
      /** Whether the payment method is enabled */
      enabled?: boolean;
    } & {
      [
        key: string
      ]: components["schemas"]["LightningNetworkPaymentMethodBaseData"];
    };
    LNURLPayPaymentMethodDataList: components["schemas"]["LNURLPayPaymentMethodData"][];
    LNURLPayPaymentMethodBaseData: {
      /** Whether to use [LUD-01](https://github.com/fiatjaf/lnurl-rfc/blob/luds/01.md)'s bech32 format or to use [LUD-17](https://github.com/fiatjaf/lnurl-rfc/blob/luds/17.md) url formatting. */
      useBech32Scheme?: boolean;
      /** Whether to allow this payment method to also be used for standard invoices and not just topup invoices. */
      enableForStandardInvoices?: boolean;
      /** Allow comments to be passed on via lnurl. */
      lud12Enabled?: boolean;
    };
    LNURLPayPaymentMethodData: {
      /** Whether the payment method is enabled. Note that this can only enabled when a Lightning Network payment method is available and enabled */
      enabled?: boolean;
      /** Crypto code of the payment method */
      cryptoCode?: string;
    } & {
      [key: string]: components["schemas"]["LNURLPayPaymentMethodBaseData"];
    };
    OnChainPaymentMethodDataList: components["schemas"]["OnChainPaymentMethodData"][];
    OnChainPaymentMethodDataWithSensitiveData: components["schemas"]["OnChainPaymentMethodData"] & {
      /** The mnemonic used to generate the wallet */
      mnemonic?: string;
    };
    OnChainPaymentMethodBaseData: {
      /** The derivation scheme */
      derivationScheme?: string;
      /** A label that will be shown in the UI */
      label?: string;
      /** The wallet fingerprint followed by the keypath to derive the account key used for signing operation or creating PSBTs */
      accountKeyPath?: string;
    };
    UpdateOnChainPaymentMethodRequest: {
      /** Whether the payment method is enabled */
      enabled?: boolean;
    } & {
      [key: string]: components["schemas"]["OnChainPaymentMethodBaseData"];
    };
    OnChainPaymentMethodData: {
      /** Whether the payment method is enabled */
      enabled?: boolean;
      /** The payment method */
      paymentMethod?: string;
    } & {
      [key: string]: components["schemas"]["OnChainPaymentMethodDataPreview"];
    };
    OnChainPaymentMethodDataPreview: {
      /** Crypto code of the payment method */
      cryptoCode?: string;
    } & {
      [key: string]: components["schemas"]["OnChainPaymentMethodBaseData"];
    };
    OnChainPaymentMethodPreviewResultData: {
      /** a list of addresses generated by the derivation scheme */
      addresses?: components["schemas"]["OnChainPaymentMethodPreviewResultAddressItem"][];
    };
    OnChainPaymentMethodPreviewResultAddressItem: {
      /** The key path relative to the account key path. */
      keyPath?: string;
      /** The address generated at the key path */
      address?: string;
    };
    GenerateOnChainWalletRequest: {
      /** An existing BIP39 mnemonic seed to generate the wallet with */
      existingMnemonic?: string;
      /** A passphrase for the BIP39 mnemonic seed */
      passphrase?: string;
      /** The account to derive from the BIP39 mnemonic seed */
      accountNumber?: number;
      /** Whether to store the seed inside BTCPay Server to enable some additional services. IF `false` AND `existingMnemonic` IS NOT SPECIFIED, BE SURE TO SECURELY STORE THE SEED IN THE RESPONSE! */
      savePrivateKeys?: boolean;
      /** Whether to import all addresses generated via BTCPay Server into the underlying node wallet. (Private keys will also be imported if `savePrivateKeys` is set to true. */
      importKeysToRPC?: boolean;
      /** If `existingMnemonic` is not set, a mnemonic is generated using the specified wordList. */
      wordList?:
        | "English"
        | "Japanese"
        | "Spanish"
        | "ChineseSimplified"
        | "ChineseTraditional"
        | "French"
        | "PortugueseBrazil"
        | "Czech";
      /** If `existingMnemonic` is not set, a mnemonic is generated using the specified wordCount. */
      wordCount?: 12 | 15 | 18 | 21 | 24;
      /** the type of wallet to generate */
      scriptPubKeyType?: "Legacy" | "Segwit" | "SegwitP2SH";
    };
    OnChainWalletOverviewData: {
      /** The total current balance of the wallet */
      balance?: string;
      /** The current unconfirmed balance of the wallet */
      unconfirmedBalance?: string;
      /** The current confirmed balance of the wallet */
      confirmedBalance?: string;
    };
    OnChainWalletFeeRateData: {
      /** The fee rate (sats per byte) based on the wallet's configured recommended block confirmation target */
      feeRate?: number;
    };
    OnChainWalletAddressData: {
      /** The bitcoin address */
      address?: string;
      /** the derivation path in relation to the HD account */
      keyPath?: string;
      /** a bip21 payment link */
      paymentLink?: string;
    };
    TransactionStatus: "Unconfirmed" | "Confirmed" | "Replaced";
    LabelData: {
      /** The type of label */
      type?: string;
      /** Information about this label */
      text?: string;
    } & { [key: string]: unknown };
    OnChainWalletTransactionData: {
      /** The transaction id */
      transactionHash?: string | null;
      /** A comment linked to the transaction */
      comment?: string;
      /** The amount the wallet balance changed with this transaction */
      amount?: string;
      /** The hash of the block that confirmed this transaction. Null if still unconfirmed. */
      blockHash?: string | null;
      /** The height of the block that confirmed this transaction. Null if still unconfirmed. */
      blockHeight?: string | null;
      /** The number of confirmations for this transaction */
      confirmations?: string | null;
      /** The time of the transaction */
      timestamp?: components["schemas"]["UnixTimestamp"];
      /** The status for this transaction */
      status?: components["schemas"]["TransactionStatus"];
      /** Labels linked to this transaction */
      labels?: { [key: string]: components["schemas"]["LabelData"] };
    };
    OnChainWalletUTXOData: {
      /** A comment linked to this utxo */
      comment?: string;
      /** the value of this utxo */
      amount?: string;
      /** a link to the configured blockchain explorer to view the utxo */
      link?: string;
      /** outpoint of this utxo */
      outpoint?: string;
      /** The time of the utxo */
      timestamp?: components["schemas"]["UnixTimestamp"];
      /** the derivation path in relation to the HD account */
      keyPath?: string;
      /** The wallet address of this utxo */
      address?: string;
      /** The number of confirmations of this utxo */
      confirmations?: number;
      /** Labels linked to this transaction */
      labels?: { [key: string]: components["schemas"]["LabelData"] };
    };
    CreateOnChainTransactionRequestDestination: {
      /** A wallet address or a BIP21 payment link */
      destination?: string;
      /** The amount to send. If `destination` is a BIP21 link, the amount must be the same or null. */
      amount?: string | null;
      /** Whether to subtract from the provided amount. Must be false if `destination` is a BIP21 link */
      subtractFromAmount?: boolean;
    };
    CreateOnChainTransactionRequest: {
      /** What and where to send money */
      destinations?: components["schemas"]["CreateOnChainTransactionRequestDestination"][];
      /** A wallet address or a BIP21 payment link */
      feeRate?: number;
      /** Whether to attempt to do a BIP78 payjoin if one of the destinations is a BIP21 with payjoin enabled */
      proceedWithPayjoin?: boolean | null;
      /** Whether to broadcast the transaction after creating it or to simply return the transaction in hex format. */
      proceedWithBroadcast?: boolean | null;
      /** Whether to send all the spent coins to the destinations (THIS CAN COST YOU SIGNIFICANT AMOUNTS OF MONEY, LEAVE FALSE UNLESS YOU KNOW WHAT YOU ARE DOING). */
      noChange?: boolean | null;
      /** Whether to enable RBF for the transaction. Leave blank to have it random (beneficial to privacy) */
      rbf?: boolean | null;
      /** Restrict the creation of the transactions from the outpoints provided ONLY (coin selection) */
      selectedInputs?: string[] | null;
    };
    StoreDataList: components["schemas"]["StoreData"][];
    StoreData: components["schemas"]["StoreBaseData"] & {
      /** The id of the store */
      id?: string;
    };
    StoreBaseData: {
      /** The name of the store */
      name?: string;
      /** The absolute url of the store */
      website?: string;
      /** The default currency of the store */
      defaultCurrency?: string;
      /** The time after which an invoice is considered expired if not paid. The value will be rounded down to a minute. */
      invoiceExpiration?: components["schemas"]["TimeSpanSeconds"];
      /** The time after which an invoice which has been paid but not confirmed will be considered invalid. The value will be rounded down to a minute. */
      monitoringExpiration?: components["schemas"]["TimeSpanSeconds"];
      speedPolicy?: components["schemas"]["SpeedPolicy"];
      /** The BOLT11 description of the lightning invoice in the checkout. You can use placeholders '{StoreName}', '{ItemDescription}' and '{OrderId}'. */
      lightningDescriptionTemplate?: string | null;
      /** Consider an invoice fully paid, even if the payment is missing 'x' % of the full amount. */
      paymentTolerance?: number;
      /** If true, then no authentication is needed to create invoices on this store. */
      anyoneCanCreateInvoice?: boolean;
      /** If true, the checkout page will ask to enter an email address before accessing payment information. */
      requiresRefundEmail?: boolean;
      /** If true, lightning payment methods show amount in satoshi in the checkout page. */
      lightningAmountInSatoshi?: boolean;
      /** Should private route hints be included in the lightning payment of the checkout page. */
      lightningPrivateRouteHints?: boolean;
      /** Include lightning invoice fallback to on-chain BIP21 payment url. */
      onChainWithLnInvoiceFallback?: boolean;
      /** After successfull payment, should the checkout page redirect the user automatically to the redirect URL of the invoice? */
      redirectAutomatically?: boolean;
      showRecommendedFee?: boolean;
      /** The fee rate recommendation in the checkout page for the on-chain payment to be confirmed after 'x' blocks. */
      recommendedFeeBlockTarget?: number;
      /** The default language to use in the checkout page. (The different translations available are listed [here](https://github.com/btcpayserver/btcpayserver/tree/master/BTCPayServer/wwwroot/locales) */
      defaultLang?: string;
      /** URL to a logo to include in the checkout page. */
      customLogo?: string | null;
      /** URL to a CSS stylesheet to include in the checkout page */
      customCSS?: string | null;
      /** The HTML title of the checkout page (when you over the tab in your browser) */
      htmlTitle?: string | null;
      networkFeeMode?: components["schemas"]["NetworkFeeMode"];
      /** If true, payjoin will be proposed in the checkout page if possible. ([More information](https://docs.btcpayserver.org/Payjoin/)) */
      payJoinEnabled?: boolean;
      /** If true, payment methods are enabled individually upon user interaction in the invoice */
      lazyPaymentMethods?: boolean;
      /** The default payment method to load when displaying an invoice. It can be in the format of `BTC_LightningNetwork` to specify Lightning to be the default or `BTC_OnChain`/ `BTC` for on-chain to be the default. */
      defaultPaymentMethod?: string;
    };
    /** Check whether network fee should be added to the invoice if on-chain payment is used. ([More information](https://docs.btcpayserver.org/FAQ/Stores/#add-network-fee-to-invoice-vary-with-mining-fees)) */
    NetworkFeeMode: "MultiplePaymentsOnly" | "Always" | "Never";
    ApplicationUserData: {
      /** The id of the user */
      id?: string;
      /** The email of the user */
      email?: string;
      /** True if the email has been confirmed by the user */
      emailConfirmed?: boolean;
      /** True if the email requires email confirmation to log in */
      requiresEmailConfirmation?: boolean;
      /** The creation date of the user as a unix timestamp. Null if created before v1.0.5.6 */
      created?: components["schemas"]["UnixTimestamp"] | null;
      /** The roles of the user */
      roles?: string[];
    };
    WebhookDeliveryList: components["schemas"]["WebhookDeliveryData"][];
    WebhookDeliveryData: {
      /** The id of the delivery */
      id?: string;
      /** Timestamp of when the delivery got broadcasted */
      timestamp?: components["schemas"]["UnixTimestamp"];
      /** HTTP code received by the remote service, if any. */
      httpCode?: number | null;
      /** User friendly error message, if any. */
      errorMessage?: string;
      /** Whether the delivery failed or not (possible values are: `Failed`, `HttpError`, `HttpSuccess`) */
      status?: string;
    };
    WebhookDataList: components["schemas"]["WebhookData"][];
    WebhookData: components["schemas"]["WebhookDataBase"] & {
      /** The id of the webhook */
      id?: string;
    };
    WebhookDataCreate: components["schemas"]["WebhookData"] & {
      /** Must be used by the callback receiver to ensure the delivery comes from BTCPay Server. BTCPay Server includes the `BTCPay-Sig` HTTP header, whose format is `sha256=HMAC256(UTF8(webhook's secret), body)`. The pattern to authenticate the webhook is similar to [how to secure webhooks in Github](https://docs.github.com/webhooks/securing/). */
      secret?: string;
    };
    WebhookDataBase: {
      /** The id of the webhook */
      id?: string;
      /** Whether this webhook is enabled or not */
      enabled?: boolean;
      /** If true, BTCPay Server will retry to redeliver any failed delivery after 10 seconds, 1 minutes and up to 6 times after 10 minutes. */
      automaticRedelivery?: boolean;
      /** The endpoint where BTCPay Server will make the POST request with the webhook body */
      url?: string;
      /** Which event should be received by this endpoint */
      authorizedEvents?: {
        /** If true, the endpoint will receive all events related to the store. */
        everything?: boolean;
        /** If `everything` is false, the specific events that the endpoint is interested in. Current events are: `InvoiceCreated`, `InvoiceReceivedPayment`, `InvoiceProcessing`, `InvoiceExpired`, `InvoiceSettled`, `InvoiceInvalid`. */
        specificEvents?: string[];
      };
    };
    WebhookEvent: {
      /** The delivery id of the webhook */
      deliveryId?: string;
      /** The id of the webhook */
      webhookId?: string;
      /** If this delivery is a redelivery, the is the delivery id of the original delivery. */
      originalDeliveryId?: string;
      /** True if this delivery is a redelivery */
      isRedelivery?: boolean;
      /** The type of this event, current available are `InvoiceCreated`, `InvoiceReceivedPayment`, `InvoicePaidInFull`, `InvoiceExpired`, `InvoiceSettled`, and `InvoiceInvalid`. */
      type?: string;
      /** The timestamp when this delivery has been created */
      timestamp?: components["schemas"]["UnixTimestamp"];
    };
    WebhookInvoiceEvent: components["schemas"]["WebhookEvent"] & {
      /** The store id of the invoice's event */
      storeId?: string;
      /** The invoice id of the invoice's event */
      invoiceId?: string;
    };
    /** Callback sent if the `type` is `InvoiceSettled` */
    WebhookInvoiceSettledEvent: components["schemas"]["WebhookInvoiceEvent"] & {
      /** Whether the invoice have been manually marked as confirmed */
      manuallyMarked?: boolean;
    } & {
      /** Whether this invoice has received more money than expected */
      overPaid?: boolean;
    };
    /** Callback sent if the `type` is `InvoiceInvalid` */
    WebhookInvoiceInvalidEvent: components["schemas"]["WebhookInvoiceEvent"] & {
      /** Whether the invoice have been manually marked as confirmed. If false, this invoice has received payments which could not confirm in time. */
      manuallyMarked?: boolean;
    };
    /** Callback sent if the `type` is `InvoiceProcessing` */
    WebhookInvoiceProcessingEvent: components["schemas"]["WebhookInvoiceEvent"] & {
      /** Whether this invoice has received more money than expected */
      overPaid?: boolean;
    };
    /** Callback sent if the `type` is `InvoiceReceivedPayment` */
    WebhookInvoiceReceivedPaymentEvent: components["schemas"]["WebhookInvoiceEvent"] & {
      /** Whether this payment has been sent after expiration of the invoice */
      afterExpiration?: boolean;
      /** What payment method was used for this payment */
      paymentMethod?: string;
      /** Details about the payment */
      payment?: components["schemas"]["InvoicePaymentMethodDataModel"];
    };
    /** Callback sent if the `type` is `InvoicePaymentSettled` */
    WebhookInvoicePaymentSettledEvent: components["schemas"]["WebhookInvoiceReceivedPaymentEvent"];
    /** Callback sent if the `type` is `InvoiceExpired` */
    WebhookInvoiceExpiredEvent: components["schemas"]["WebhookInvoiceEvent"] & {
      /** Whether the invoice received some payments before being expired. */
      partiallyPaid?: boolean;
    };
  };
}

export interface operations {
  /** Check the instance health status */
  Health_GetHealth: {
    responses: {
      /** Instance is up */
      200: {
        content: {
          "application/json": components["schemas"]["ApplicationHealthData"];
        };
      };
    };
  };
  /** View information about the existing invoices */
  Invoices_GetInvoices: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
      };
      query: {
        /** Array of OrderIds to fetch the invoices for */
        orderId?: string[];
        /** A term that can help locating specific invoices. */
        textSearch?: string;
        /** Number of records to skip */
        skip?: number | null;
        /** Number of records returned in response */
        take?: number | null;
      };
    };
    responses: {
      /** list of invoices */
      200: {
        content: {
          "application/json": components["schemas"]["InvoiceDataList"];
        };
      };
    };
  };
  /** Create a new invoice */
  Invoices_CreateInvoice: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
      };
    };
    responses: {
      /** Information about the new invoice */
      200: {
        content: {
          "application/json": components["schemas"]["InvoiceData"];
        };
      };
      /** A list of errors that occurred when creating the invoice */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to add new invoices */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateInvoiceRequest"];
      };
    };
  };
  /** View information about the specified invoice */
  Invoices_GetInvoice: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The invoice to fetch */
        invoiceId: string;
      };
    };
    responses: {
      /** specified invoice */
      200: {
        content: {
          "application/json": components["schemas"]["InvoiceData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified invoice */
      403: unknown;
      /** The key is not found for this invoice */
      404: unknown;
    };
  };
  /** Updates the specified invoice. */
  Invoices_UpdateInvoice: {
    parameters: {
      path: {
        /** The store the invoice belongs to */
        storeId: string;
        /** The invoice to update */
        invoiceId: string;
      };
    };
    responses: {
      /** The invoice that has been updated */
      200: {
        content: {
          "application/json": components["schemas"]["InvoiceData"];
        };
      };
      /** A list of errors that occurred when updating the invoice */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the specified invoice */
      403: unknown;
      /** The key is not found for this invoice */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateInvoiceRequest"];
      };
    };
  };
  /** Archives the specified invoice. */
  Invoices_ArchiveInvoice: {
    parameters: {
      path: {
        /** The store the invoice belongs to */
        storeId: string;
        /** The invoice to remove */
        invoiceId: string;
      };
    };
    responses: {
      /** The invoice has been archived */
      200: unknown;
      /** A list of errors that occurred when archiving the invoice */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to archive the specified invoice */
      403: unknown;
      /** The key is not found for this invoice */
      404: unknown;
    };
  };
  /** View information about the specified invoice's payment methods */
  Invoices_GetInvoicePaymentMethods: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The invoice to fetch */
        invoiceId: string;
      };
      query: {
        /** If default or true, only returns payments which are accounted (in Bitcoin, this mean not returning RBF'd or double spent payments) */
        onlyAccountedPayments?: boolean;
      };
    };
    responses: {
      /** specified invoice payment methods data */
      200: {
        content: {
          "application/json": components["schemas"]["InvoicePaymentMethodDataModel"][];
        };
      };
      /** If you are authenticated but forbidden to view the specified invoice */
      403: unknown;
      /** The key is not found for this invoice */
      404: unknown;
    };
  };
  /** Mark an invoice as invalid or settled. */
  Invoices_MarkInvoiceStatus: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
        /** The invoice to update */
        invoiceId: string;
      };
    };
    responses: {
      /** The updated invoice */
      200: {
        content: {
          "application/json": components["schemas"]["InvoiceData"];
        };
      };
      /** A list of errors that occurred when updating the invoice */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the invoice */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MarkInvoiceStatusRequest"];
      };
    };
  };
  /** Unarchive an invoice */
  Invoices_UnarchiveInvoice: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
        /** The invoice to update */
        invoiceId: string;
      };
    };
    responses: {
      /** The unarchived invoice */
      200: {
        content: {
          "application/json": components["schemas"]["InvoiceData"];
        };
      };
      /** A list of errors that occurred when updating the invoice */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the invoice */
      403: unknown;
    };
  };
  /** Activate an invoice payment method (if lazy payments mode is enabled) */
  Invoices_ActivatePaymentMethod: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
        /** The invoice to update */
        invoiceId: string;
        /** The payment method to activate */
        paymentMethod: string;
      };
    };
    responses: {
      200: unknown;
      /** A list of errors that occurred when updating the invoice */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to activate the invoice payment method */
      403: unknown;
    };
  };
  /** View information about the lightning node */
  InternalLightningNodeApi_GetInfo: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** Lightning node information such as reachable nodeinfos */
      200: {
        content: {
          "application/json": components["schemas"]["LightningNodeInformationData"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
  };
  /** Connect to another lightning node. */
  InternalLightningNodeApi_ConnectToNode: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** Successfully connected */
      200: unknown;
      /** Wellknown error codes are: `could-not-connect` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectToNodeRequest"];
      };
    };
  };
  /** View information about the current channels of the lightning node */
  InternalLightningNodeApi_GetChannels: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** list of channels */
      200: {
        content: {
          "application/json": components["schemas"]["LightningChannelData"][];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
    };
  };
  /** Open a channel with another lightning node. You should connect to that node first. */
  InternalLightningNodeApi_OpenChannel: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** Successfully opened */
      200: unknown;
      /** Wellknown error codes are: `channel-already-exists`, `cannot-afford-funding`, `need-more-confirmations`, `peer-not-connected` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OpenLightningChannelRequest"];
      };
    };
  };
  /** Get an on-chain deposit address for the lightning node */
  InternalLightningNodeApi_GetDepositAddress: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** deposit address */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
  };
  /** View information about the requested lightning invoice */
  InternalLightningNodeApi_GetInvoice: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The id of the lightning invoice. */
        id: string;
      };
    };
    responses: {
      /** Lightning invoice data */
      200: {
        content: {
          "application/json": components["schemas"]["LightningInvoiceData"];
        };
      };
      /** The lightning node configuration or the specified invoice was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
  };
  /** Pay a lightning invoice. */
  InternalLightningNodeApi_PayInvoice: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** Successfully paid */
      200: unknown;
      /** Wellknown error codes are: `could-not-find-route`, `generic-error` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PayLightningInvoiceRequest"];
      };
    };
  };
  /** Create a lightning invoice. */
  InternalLightningNodeApi_CreateInvoice: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
      };
    };
    responses: {
      /** Successfully created */
      200: {
        content: {
          "application/json": components["schemas"]["LightningInvoiceData"];
        };
      };
      /** Wellknown error codes are: `invoice-error` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateLightningInvoiceRequest"];
      };
    };
  };
  /** View information about the lightning node */
  StoreLightningNodeApi_GetInfo: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** Lightning node information such as reachable nodeinfos */
      200: {
        content: {
          "application/json": components["schemas"]["LightningNodeInformationData"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
  };
  /** Connect to another lightning node. */
  StoreLightningNodeApi_ConnectToNode: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** Successfully connected */
      200: unknown;
      /** Wellknown error codes are: `could-not-connect` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ConnectToNodeRequest"];
      };
    };
  };
  /** View information about the current channels of the lightning node */
  StoreLightningNodeApi_GetChannels: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** list of channels */
      200: {
        content: {
          "application/json": components["schemas"]["LightningChannelData"][];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
    };
  };
  /** Open a channel with another lightning node. You should connect to that node first. */
  StoreLightningNodeApi_OpenChannel: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** Successfully opened */
      200: unknown;
      /** Wellknown error codes are: `channel-already-exists`, `cannot-afford-funding`, `need-more-confirmations`, `peer-not-connected` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OpenLightningChannelRequest"];
      };
    };
  };
  /** Get an on-chain deposit address for the lightning node */
  StoreLightningNodeApi_GetDepositAddress: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** deposit address */
      200: {
        content: {
          "application/json": string;
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
  };
  /** View information about the requested lightning invoice */
  StoreLightningNodeApi_GetInvoice: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
        /** The id of the lightning invoice. */
        id: string;
      };
    };
    responses: {
      /** Lightning invoice data */
      200: {
        content: {
          "application/json": components["schemas"]["LightningInvoiceData"];
        };
      };
      /** The lightning node configuration or the specified invoice was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
  };
  /** Pay a lightning invoice. */
  StoreLightningNodeApi_PayInvoice: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** Successfully paid */
      200: unknown;
      /** Wellknown error codes are: `could-not-find-route`, `generic-error` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PayLightningInvoiceRequest"];
      };
    };
  };
  /** Create a lightning invoice. */
  StoreLightningNodeApi_CreateInvoice: {
    parameters: {
      path: {
        /** The cryptoCode of the lightning-node to query */
        cryptoCode: string;
        /** The store id with the lightning-node configuration to query */
        storeId: string;
      };
    };
    responses: {
      /** Successfully created */
      200: {
        content: {
          "application/json": components["schemas"]["LightningInvoiceData"];
        };
      };
      /** Wellknown error codes are: `invoice-error` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The lightning node configuration was not found */
      404: unknown;
      /** Unable to access the lightning node */
      503: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateLightningInvoiceRequest"];
      };
    };
  };
  /** The metadata of available permissions */
  permissionsMetadata: {
    responses: {
      /** The metadata of available permissions */
      200: {
        content: {
          "application/json": {
            /** The permission id */
            name?: string;
            /** Permissions included in this array are also granted by this permission */
            included?: string[];
          }[];
        };
      };
    };
  };
  /** The supported language codes */
  langCodes: {
    responses: {
      /** The supported language codes */
      200: {
        content: {
          "application/json": {
            /** The language code */
            code?: string;
            /** The language name */
            currentLanguage?: string;
          }[];
        };
      };
    };
  };
  /** View current user's notifications */
  Notifications_GetNotifications: {
    parameters: {
      query: {
        /** filter by seen notifications */
        seen?: string | null;
      };
    };
    responses: {
      /** list of notifications */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationData"];
        };
      };
    };
  };
  /** View information about the specified notification */
  Notifications_GetNotification: {
    parameters: {
      path: {
        /** The notification to fetch */
        id: string;
      };
    };
    responses: {
      /** specified notification */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified notification */
      403: unknown;
      /** The key is not found for this notification */
      404: unknown;
    };
  };
  /** Updates the notification */
  Notifications_UpdateNotification: {
    parameters: {
      path: {
        /** The notification to update */
        id: string;
      };
    };
    responses: {
      /** updated notification */
      200: {
        content: {
          "application/json": components["schemas"]["NotificationData"];
        };
      };
      /** If you are authenticated but forbidden to update the specified notification */
      403: unknown;
      /** The key is not found for this notification */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNotification"];
      };
    };
  };
  /** Removes the specified notification. */
  Notifications_DeleteNotification: {
    parameters: {
      path: {
        /** The notification to remove */
        id: string;
      };
    };
    responses: {
      /** The notification has been deleted */
      200: unknown;
      /** If you are authenticated but forbidden to remove the specified notification */
      403: unknown;
      /** The key is not found for this notification */
      404: unknown;
    };
  };
  /** View information about the existing payment requests */
  PaymentRequests_GetPaymentRequests: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
      };
    };
    responses: {
      /** list of payment requests */
      200: {
        content: {
          "application/json": components["schemas"]["PaymentRequestDataList"];
        };
      };
    };
  };
  /** Create a new payment request */
  PaymentRequests_CreatePaymentRequest: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
      };
    };
    responses: {
      /** Information about the new payment request */
      200: {
        content: {
          "application/json": components["schemas"]["PaymentRequestData"];
        };
      };
      /** A list of errors that occurred when creating the payment request */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to add new payment requests */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PaymentRequestBaseData"];
      };
    };
  };
  /** View information about the specified payment request */
  PaymentRequests_GetPaymentRequest: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The payment request to fetch */
        paymentRequestId: string;
      };
    };
    responses: {
      /** specified payment request */
      200: {
        content: {
          "application/json": components["schemas"]["PaymentRequestData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified payment request */
      403: unknown;
      /** The key is not found for this payment request */
      404: unknown;
    };
  };
  /** Update a payment request */
  PaymentRequests_UpdatePaymentRequest: {
    parameters: {
      path: {
        /** The store to query */
        storeId: string;
        /** The payment request to update */
        paymentRequestId: string;
      };
    };
    responses: {
      /** The updated payment request */
      200: {
        content: {
          "application/json": components["schemas"]["PaymentRequestData"];
        };
      };
      /** A list of errors that occurred when updating the payment request */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the payment request */
      403: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PaymentRequestBaseData"];
      };
    };
  };
  /** Archives the specified payment request. */
  PaymentRequests_ArchivePaymentRequest: {
    parameters: {
      path: {
        /** The store the payment request belongs to */
        storeId: string;
        /** The payment request to remove */
        paymentRequestId: string;
      };
    };
    responses: {
      /** The payment request has been archived */
      200: unknown;
      /** A list of errors that occurred when archiving the payment request */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to archive the specified payment request */
      403: unknown;
      /** The key is not found for this payment request */
      404: unknown;
    };
  };
  /** Get the pull payments of a store */
  PullPayments_GetPullPayments: {
    parameters: {
      path: {
        /** The store ID */
        storeId: string;
      };
      query: {
        /** Whether this should list archived pull payments */
        includeArchived?: boolean;
      };
    };
    responses: {
      /** List of pull payments */
      200: {
        content: {
          "application/json": components["schemas"]["PullPaymentDataList"];
        };
      };
    };
  };
  /** A pull payment allows its receiver to ask for payouts up to `amount` of `currency` every `period`. */
  PullPayments_CreatePullPayment: {
    parameters: {
      path: {
        /** The store ID */
        storeId: string;
      };
    };
    responses: {
      /** The create pull payment */
      200: {
        content: {
          "application/json": components["schemas"]["PullPaymentData"];
        };
      };
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the pull payment */
          name?: string | null;
          /** The amount in `currency` of this pull payment as a decimal string */
          amount?: string;
          /** The currency of the amount. */
          currency?: string;
          /** The length of each period in seconds. */
          period?: number | null;
          /** When this pull payment is effective. Already started if null or unspecified. */
          startsAt?: number | null;
          /** When this pull payment expires. Never expires if null or unspecified. */
          expiresAt?: number | null;
          /** The list of supported payment methods supported by this pull payment. Available options can be queried from the `StorePaymentMethods_GetStorePaymentMethods` endpoint */
          paymentMethods?: string[];
        };
      };
    };
  };
  /** Get a pull payment */
  PullPayments_GetPullPayment: {
    parameters: {
      path: {
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
    };
    responses: {
      /** Information about the pull payment */
      200: {
        content: {
          "application/json": components["schemas"]["PullPaymentData"];
        };
      };
      /** Pull payment not found */
      404: unknown;
    };
  };
  /** Archive this pull payment (Will cancel all payouts awaiting for payment) */
  PullPayments_ArchivePullPayment: {
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
    };
    responses: {
      /** The pull payment has been archived */
      200: unknown;
      /** The pull payment has not been found, or does not belong to this store */
      404: unknown;
    };
  };
  /** Get payouts */
  PullPayments_GetPayouts: {
    parameters: {
      path: {
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
      query: {
        /** Whether this should list cancelled payouts */
        includeCancelled?: boolean;
      };
    };
    responses: {
      /** The payouts of the pull payment */
      200: {
        content: {
          "application/json": components["schemas"]["PayoutDataList"];
        };
      };
      /** Pull payment not found */
      404: unknown;
    };
  };
  /** Create a new payout */
  PullPayments_CreatePayout: {
    parameters: {
      path: {
        /** The ID of the pull payment */
        pullPaymentId: string;
      };
    };
    responses: {
      /** A new payout has been created */
      200: {
        content: {
          "application/json": components["schemas"]["PayoutData"];
        };
      };
      /** Wellknown error codes are: `duplicate-destination`, `expired`, `not-started`, `archived`, `overdraft`, `amount-too-low`, `payment-method-not-supported` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** Pull payment not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePayoutRequest"];
      };
    };
  };
  /** Approve a payout */
  PullPayments_ApprovePayout: {
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the payout */
        payoutId: string;
      };
    };
    responses: {
      /** The payout has been approved, transitioning to `AwaitingPayment` state. */
      200: {
        content: {
          "application/json": components["schemas"]["PayoutData"];
        };
      };
      /** Wellknown error codes are: `rate-unavailable`, `invalid-state`, `amount-too-low`, `old-revision` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The payout is not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The revision number of the payout being modified */
          revision?: number;
          /** The rate rule to calculate the rate of the payout. This can also be a fixed decimal. (if null or unspecified, will use the same rate setting as the store's settings) */
          rateRule?: string | null;
        };
      };
    };
  };
  /** Cancel the payout */
  PullPayments_CancelPayout: {
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the payout */
        payoutId: string;
      };
    };
    responses: {
      /** The payout has been cancelled */
      200: unknown;
      /** The payout is not found */
      404: unknown;
    };
  };
  /** Mark a payout as paid */
  PullPayments_MarkPayoutPaid: {
    parameters: {
      path: {
        /** The ID of the store */
        storeId: string;
        /** The ID of the payout */
        payoutId: string;
      };
    };
    responses: {
      /** The payout has been marked paid, transitioning to `Completed` state. */
      200: unknown;
      /** Wellknown error codes are: `invalid-state` */
      400: {
        content: {
          "application/json": components["schemas"]["ProblemDetails"];
        };
      };
      /** The payout is not found */
      404: unknown;
      /** Unable to validate the request */
      422: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
    };
  };
  /** Information about the server, chains and sync states */
  ServerInfo_GetServerInfo: {
    responses: {
      /** Server information */
      200: {
        content: {
          "application/json": components["schemas"]["ApplicationServerInfoData"];
        };
      };
    };
  };
  /** View information about the stores' configured payment methods */
  StorePaymentMethods_GetStorePaymentMethods: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
      };
      query: {
        /** Fetch payment methods that are enabled/disabled only */
        enabled?: boolean;
      };
    };
    responses: {
      /** list of payment methods */
      200: {
        content: {
          "application/json": {
            [key: string]: components["schemas"]["GenericPaymentMethodData"];
          };
        };
      };
    };
  };
  /** View information about the stores' configured Lightning Network payment methods */
  StoreLightningNetworkPaymentMethods_GetLightningNetworkPaymentMethods: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
      };
      query: {
        /** Fetch payment methods that are enabled/disabled only */
        enabled?: boolean;
      };
    };
    responses: {
      /** list of payment methods */
      200: {
        content: {
          "application/json": components["schemas"]["LightningNetworkPaymentMethodDataList"];
        };
      };
    };
  };
  /** View information about the specified payment method */
  StoreLightningNetworkPaymentMethods_GetLightningNetworkPaymentMethod: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
    };
    responses: {
      /** specified payment method */
      200: {
        content: {
          "application/json": components["schemas"]["LightningNetworkPaymentMethodData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/payment method */
      404: unknown;
    };
  };
  /** Update the specified store's payment method */
  StoreLightningNetworkPaymentMethods_UpdateLightningNetworkPaymentMethod: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to update */
        cryptoCode: string;
      };
    };
    responses: {
      /** updated specified payment method */
      200: {
        content: {
          "application/json": components["schemas"]["LightningNetworkPaymentMethodData"];
        };
      };
      /** A list of errors that occurred when updating the store payment method */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the specified store */
      403: unknown;
      /** The key is not found for this store */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateLightningNetworkPaymentMethodRequest"];
      };
    };
  };
  /** View information about the stores' configured LNURL payment methods */
  StoreLNURLPayPaymentMethods_GetLNURLPayPaymentMethods: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
      };
      query: {
        /** Fetch payment methods that are enabled/disabled only */
        enabled?: boolean;
      };
    };
    responses: {
      /** list of payment methods */
      200: {
        content: {
          "application/json": components["schemas"]["LNURLPayPaymentMethodDataList"];
        };
      };
    };
  };
  /** View information about the specified payment method */
  StoreLNURLPayPaymentMethods_GetLNURLPayPaymentMethod: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
    };
    responses: {
      /** specified payment method */
      200: {
        content: {
          "application/json": components["schemas"]["LNURLPayPaymentMethodData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/payment method */
      404: unknown;
    };
  };
  /** Update the specified store's payment method */
  StoreLNURLPayPaymentMethods_UpdateLNURLPayPaymentMethod: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to update */
        cryptoCode: string;
      };
    };
    responses: {
      /** updated specified payment method */
      200: {
        content: {
          "application/json": components["schemas"]["LNURLPayPaymentMethodData"];
        };
      };
      /** A list of errors that occurred when updating the store payment method */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the specified store */
      403: unknown;
      /** The key is not found for this store */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LNURLPayPaymentMethodData"];
      };
    };
  };
  /** View information about the stores' configured on-chain payment methods */
  StoreOnChainPaymentMethods_GetOnChainPaymentMethods: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
      };
      query: {
        /** Fetch payment methods that are enabled/disabled only */
        enabled?: boolean;
      };
    };
    responses: {
      /** list of payment methods */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainPaymentMethodDataList"];
        };
      };
    };
  };
  /** View information about the specified payment method */
  StoreOnChainPaymentMethods_GetOnChainPaymentMethod: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
    };
    responses: {
      /** specified payment method */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainPaymentMethodData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/payment method */
      404: unknown;
    };
  };
  /** Update the specified store's payment method */
  StoreOnChainPaymentMethods_UpdateOnChainPaymentMethod: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to update */
        cryptoCode: string;
      };
    };
    responses: {
      /** updated specified payment method */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainPaymentMethodData"];
        };
      };
      /** A list of errors that occurred when updating the store payment method */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the specified store */
      403: unknown;
      /** The key is not found for this store */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateOnChainPaymentMethodRequest"];
      };
    };
  };
  /** View addresses of a proposed payment method of the store */
  StoreOnChainPaymentMethods_GetOnChainPaymentMethodPreview: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
      query: {
        /** From which index to fetch the addresses */
        offset?: number;
        /** Number of addresses to preview */
        amount?: number;
      };
    };
    responses: {
      /** specified payment method addresses */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainPaymentMethodPreviewResultData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OnChainPaymentMethodDataPreview"];
      };
    };
  };
  /** View information about the specified wallet */
  StoreOnChainWallets_ShowOnChainWalletOverview: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
    };
    responses: {
      /** specified wallet */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainWalletOverviewData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
  };
  /** Get wallet onchain fee rate */
  StoreOnChainWallets_GetOnChainFeeRate: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
      query: {
        /** The number of blocks away you are willing to target for confirmation. Defaults to the wallet's configured `RecommendedFeeBlockTarget` */
        blockTarget?: number;
      };
    };
    responses: {
      /** fee rate */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainWalletFeeRateData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
  };
  /** Get or generate address for wallet */
  StoreOnChainWallets_GetOnChainWalletReceiveAddress: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
      query: {
        /** Whether to generate a new address for this request even if the previous one was not used */
        forceGenerate?: string;
      };
    };
    responses: {
      /** reserved address */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainWalletAddressData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
  };
  /** UnReserve address */
  StoreOnChainWallets_UnReserveOnChainWalletReceiveAddress: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the payment method to fetch */
        cryptoCode: string;
      };
    };
    responses: {
      /** address unreserved */
      200: unknown;
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet or there was no address reserved */
      404: unknown;
    };
  };
  /** Get store on-chain wallet transactions */
  StoreOnChainWallets_ShowOnChainWalletTransactions: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the wallet to fetch */
        cryptoCode: string;
      };
      query: {
        /** Statuses to filter the transactions with */
        statusFilter?: components["schemas"]["TransactionStatus"][];
        /** Number of transactions to skip from the start */
        skip?: number;
        /** Maximum number of transactions to return */
        limit?: number;
      };
    };
    responses: {
      /** transactions list */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainWalletTransactionData"][];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
  };
  /** Create store on-chain wallet transaction */
  StoreOnChainWallets_CreateOnChainTransaction: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the wallet */
        cryptoCode: string;
      };
    };
    responses: {
      /** the tx */
      200: {
        content: {
          "application/json":
            | string
            | components["schemas"]["OnChainWalletTransactionData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOnChainTransactionRequest"];
      };
    };
  };
  /** Get store on-chain wallet transaction */
  StoreOnChainWallets_GetOnChainWalletTransaction: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the wallet to fetch */
        cryptoCode: string;
        /** The transaction id to fetch */
        transactionId: string;
      };
    };
    responses: {
      /** transaction */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainWalletTransactionData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
  };
  /** Get store on-chain wallet utxos */
  StoreOnChainWallets_GetOnChainWalletUTXOs: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
        /** The crypto code of the wallet to fetch */
        cryptoCode: string;
      };
    };
    responses: {
      /** utxo list */
      200: {
        content: {
          "application/json": components["schemas"]["OnChainWalletUTXOData"][];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store/wallet */
      404: unknown;
    };
  };
  /** View information about the available stores */
  Stores_GetStores: {
    responses: {
      /** list of stores */
      200: {
        content: {
          "application/json": components["schemas"]["StoreDataList"];
        };
      };
    };
  };
  /** View information about the specified store */
  Stores_GetStore: {
    parameters: {
      path: {
        /** The store to fetch */
        storeId: string;
      };
    };
    responses: {
      /** specified store */
      200: {
        content: {
          "application/json": components["schemas"]["StoreData"];
        };
      };
      /** If you are authenticated but forbidden to view the specified store */
      403: unknown;
      /** The key is not found for this store */
      404: unknown;
    };
  };
  /** Update the specified store */
  Stores_UpdateStore: {
    parameters: {
      path: {
        /** The store to update */
        storeId: string;
      };
    };
    responses: {
      /** updated specified store */
      200: {
        content: {
          "application/json": components["schemas"]["StoreData"];
        };
      };
      /** A list of errors that occurred when updating the store */
      400: {
        content: {
          "application/json": components["schemas"]["ValidationProblemDetails"];
        };
      };
      /** If you are authenticated but forbidden to update the specified store */
      403: unknown;
      /** The key is not found for this store */
      404: unknown;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["StoreData"];
      };
    };
  };
  /** View information about the current user */
  Users_GetCurrentUser: {
    responses: {
      /** Information about the current user */
      200: {
        content: {
          "application/json": components["schemas"]["ApplicationUserData"];
        };
      };
    };
  };
  /** Deletes user profile and associated user data for user making the request */
  Users_DeleteCurrentUser: {
    responses: {
      /** User and associated data deleted successfully */
      200: unknown;
    };
  };
  /** View webhooks of a store */
  Webhokks_GetWebhooks: {
    parameters: {
      path: {
        /** The store id */
        storeId: string;
      };
    };
    responses: {
      /** List of webhooks */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookDataList"];
        };
      };
    };
  };
  /** View webhook of a store */
  Webhokks_GetWebhook: {
    parameters: {
      path: {
        /** The store id */
        storeId: string;
        /** The webhook id */
        webhookId: string;
      };
    };
    responses: {
      /** A webhook */
      200: {
        content: {
          "application/json": components["schemas"]["WebhookData"];
        };
      };
      /** The webhook has not been found */
      404: unknown;
    };
  };
}

export interface external {}
